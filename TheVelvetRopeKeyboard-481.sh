#!/usr/bin/env bash
set +H; f="$HOME/.bash_cards"; t="/tmp/bash.$$"; mkdir -p "$(dirname "$f")" "$t"; touch "$f"; b(){ p=('(^|[[:space:]]|;|&&)rm[[:space:]]+-rf[[:space:]]+/' '(^|[[:space:]]|;|&&)mkfs' '(^|[[:space:]]|;|&&)dd[[:space:]]+if=' '(^|[[:space:]]|;|&&)shutdown' '(^|[[:space:]]|;|&&)reboot'); for r in "${p[@]}"; do printf '%s' "$1" | grep -Eiq -- "$r" && return 0; done; return 1; }; m(){ awk -v q="$1" -F'\t' 'BEGIN{IGNORECASE=1; gsub(/[^[:alnum:]]+/," ",q); nq=split(q,qw," "); for(i=1;i<=nq;i++) if(qw[i]!=""){seen[tolower(qw[i])]=1; sc++}} { phrase=$1; cmd=$2; gsub(/[^[:alnum:]]+/," ",phrase); n=split(phrase,pw," "); delete u; pu=0; inter=0; for(i=1;i<=n;i++){ w=tolower(pw[i]); if(w=="") continue; if(!(w in u)){u[w]=1; pu++} if(w in seen) inter++ } union=pu+sc-inter; score=(union>0?inter/union:0); printf "%.6f\t%s\t%s\n",score,$1,$2 }' "$f" | sort -rn | head -n1; }; r(){ b "$1" && echo "[blocked]" && return; bash -lc "$1" || :; }; k(){ n=("~ 1 2 3 4 5 6 7 8 9 0 - = BK" " q w e r t y u i o p [ ]" " a s d f g h j k l ; ' ENT" " z x c v b n m , . /" " SP SH SAVE"); s=("~ ! @ # $ % ^ & * ( ) _ + BK" " Q W E R T Y U I O P { }" " A S D F G H J K L : \" ENT" " Z X C V B N M < > ?" " SP SH SAVE"); x=4; y=2; sh=false; f1=1; p=""; c_=""; while :; do clear; echo "BASH CARDS"; echo "Shift:$([[ $sh == true ]] && echo ON || echo OFF) Field:$([[ $f1 -eq 1 ]] && echo PHRASE || echo CMD)"; echo "P:$p"; echo "C:$c_"; [[ $sh == true ]] && kb=("${s[@]}") || kb=("${n[@]}"); for ((Y=0; Y<${#kb[@]}; Y++)); do read -r -a ks <<< "${kb[$Y]}"; r_=""; for ((X=0; X<${#ks[@]}; X++)); do k_="${ks[$X]}"; cell=$(printf "%-3s" "$k_"); if (( X==x && Y==y )); then r_+="[$cell]"; else r_+="$cell "; fi; done; echo "$r_"; done; IFS= read -rsn1 i || :; case "$i" in w) ((y>0)) && ((y--)) ;; s) ((y<${#n[@]}-1)) && ((y++)) ;; a) ((x>0)) && ((x--)) ;; d) read -r -a rk <<< "${n[$y]}"; ((x<${#rk[@]}-1)) && ((x++)) ;; e) read -r -a row <<< "${kb[$y]}"; k_="${row[$x]:-}"; case "$k_" in BK) if [[ $f1 -eq 1 ]]; then p="${p%?}"; else c_="${c_%?}"; fi ;; ENT) if [[ $f1 -eq 1 ]]; then f1=2; else f1=1; fi ;; SAVE) if [[ -n "$p" && -n "$c_" ]]; then printf "%s\t%s\n" "$p" "$c_" >> "$f"; echo "[saved] $p -> $c_"; read -r _; p=""; c_=""; f1=1; elif [[ -z "$p" && -n "$c_" ]]; then echo "[exec] $c_"; r "$c_"; read -r _; break; elif [[ -n "$p" && -z "$c_" ]]; then printf "%s" "$p" > "$t/x"; break; fi ;; SP) if [[ $f1 -eq 1 ]]; then p+=" "; else c_+=" "; fi ;; SH) sh=$([[ $sh == false ]] && echo true || echo false) ;; *) if [[ $f1 -eq 1 ]]; then p+="$k_"; else c_+="$k_"; fi ;; esac ;; q) break ;; esac; done; }; echo ":: q quit add show del enter"; while :; do if [[ -f "$t/x" ]]; then l=$(<"$t/x"); rm -f "$t/x"; l=$(echo "$l" | tr -d '\r' | xargs); echo "[kb] $l"; else printf "â€º "; IFS= read -r l || :; fi; [[ -z "$l" ]] && continue; [[ "$l" =~ ^(q|quit|exit)$ ]] && break; if [[ "$l" == enter ]]; then k; continue; fi; if [[ "$l" == add ]]; then printf "p:"; read -r p; printf "c:"; read -r c_; [[ -n "$p" && -n "$c_" ]] && printf "%s\t%s\n" "$p" "$c_" >> "$f"; continue; fi; if [[ "$l" == show ]]; then nl -ba "$f"; continue; fi; if [[ "$l" == del ]]; then nl -ba "$f" | tail -n20; printf "#:"; read -r n; [[ $n =~ ^[0-9]+$ ]] && awk -v n="$n" 'NR!=n' "$f" > "$f.tmp" && mv "$f.tmp" "$f" && echo "[deleted]" || echo "[invalid]"; continue; fi; best=$(m "$l"); sc=$(cut -f1 <<< "$best"); cm=$(cut -f3- <<< "$best"); awk -v s="$sc" 'BEGIN{exit!(s>=0.25)}' && r "$cm" || r "$l"; done; rm -rf "$t"
